function B=interpolate(A)% INPAINT_NANS: in-paints over nans in an array%% Solves approximation to one of several pdes to% interpolate and extrapolate holes in an array%% arguments (input):%   A - nxm array with some NaNs to be filled in%%% I always need to know which elements are NaN,% and what size the array is for any method[n,m]=size(A);A=A(:);nm=n*m;k=isnan(A(:));% list the nodes which are known, and which will% be interpolatednan_list=find(k);known_list=find(~k);% how many nans overallnan_count=length(nan_list);% convert NaN indices to (r,c) form% nan_list==find(k) are the unrolled (linear) indices% (row,column) form[nr,nc]=ind2sub([n,m],nan_list);% both forms of index in one array:% column 1 == unrolled index% column 2 == row index% column 3 == column indexnan_list=[nan_list,nr,nc];% supply default methodif (nargin<2) || isempty(method)  method = 0;elseif ~ismember(method,0:5)  error 'If supplied, method must be one of: {0,1,2,3,4,5}.'end  % least squares approach with del^2. Build system  % for every array element as an unknown, and then  % eliminate those which are knowns.  % Build sparse matrix approximating del^2 for  % every element in A.    % is it 1-d or 2-d?  if (m == 1) || (n == 1)    % a 1-d case    u = (1:(nm-2))';    fda = sparse(repmat(u,1,3),bsxfun(@plus,u,0:2), ...      repmat([1 -2 1],nm-2,1),nm-2,nm);  else    % a 2-d case        % Compute finite difference for second partials    % on row variable first    [i,j]=ndgrid(2:(n-1),1:m);    ind=i(:)+(j(:)-1)*n;    np=(n-2)*m;    fda=sparse(repmat(ind,1,3),[ind-1,ind,ind+1], ...      repmat([1 -2 1],np,1),n*m,n*m);        % now second partials on column variable    [i,j]=ndgrid(1:n,2:(m-1));    ind=i(:)+(j(:)-1)*n;    np=n*(m-2);    fda=fda+sparse(repmat(ind,1,3),[ind-n,ind,ind+n], ...      repmat([1 -2 1],np,1),nm,nm);  end    % eliminate knowns  rhs=-fda(:,known_list)*A(known_list);  k=find(any(fda(:,nan_list),2));    % and solve...  B=A;  B(nan_list(:,1))=fda(k,nan_list(:,1))\rhs(k);  % all done, make sure that B is the same shape as% A was when we came in.B=reshape(B,n,m);% ====================================================%      end of main function% ====================================================% ====================================================%      begin subfunctions% ====================================================function neighbors_list=identify_neighbors(n,m,nan_list,talks_to)% identify_neighbors: identifies all the neighbors of%   those nodes in nan_list, not including the nans%   themselves%% arguments (input):%  n,m - scalar - [n,m]=size(A), where A is the%      array to be interpolated%  nan_list - array - list of every nan element in A%      nan_list(i,1) == linear index of i'th nan element%      nan_list(i,2) == row index of i'th nan element%      nan_list(i,3) == column index of i'th nan element%  talks_to - px2 array - defines which nodes communicate%      with each other, i.e., which nodes are neighbors.%%      talks_to(i,1) - defines the offset in the row%                      dimension of a neighbor%      talks_to(i,2) - defines the offset in the column%                      dimension of a neighbor%      %      For example, talks_to = [-1 0;0 -1;1 0;0 1]%      means that each node talks only to its immediate%      neighbors horizontally and vertically.% % arguments(output):%  neighbors_list - array - list of all neighbors of%      all the nodes in nan_listif ~isempty(nan_list)  % use the definition of a neighbor in talks_to  nan_count=size(nan_list,1);  talk_count=size(talks_to,1);    nn=zeros(nan_count*talk_count,2);  j=[1,nan_count];  for i=1:talk_count    nn(j(1):j(2),:)=nan_list(:,2:3) + ...        repmat(talks_to(i,:),nan_count,1);    j=j+nan_count;  end    % drop those nodes which fall outside the bounds of the  % original array  L = (nn(:,1)<1)|(nn(:,1)>n)|(nn(:,2)<1)|(nn(:,2)>m);   nn(L,:)=[];    % form the same format 3 column array as nan_list  neighbors_list=[sub2ind([n,m],nn(:,1),nn(:,2)),nn];    % delete replicates in the neighbors list  neighbors_list=unique(neighbors_list,'rows');    % and delete those which are also in the list of NaNs.  neighbors_list=setdiff(neighbors_list,nan_list,'rows');  else  neighbors_list=[];end